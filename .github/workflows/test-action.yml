name: 'Show Variables' # Original name maintained

on:
  workflow_dispatch:
    inputs:
      deployment_type:
        type: choice
        description: Select type of deployment
        options:
          - Release from Commit
          - Major
          - Minor
          - Patch
        default: 'Release from Commit'
      commit_hash:
        description: 'The hash of thee commit that should be deployed, defaults to the latest commit on main'
        required: false
        type: string

      deployment_environment:
        type: choice
        required: true
        description: On which environment should the deployment be done?
        options:
          - 'No deployment (only build)'
          - PROD
          - STAGING
          - DEMO
        default: 'No deployment (only build)'


jobs:
  debug:
    runs-on: ubuntu-24.04
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }} # Kept for consistency if needed elsewhere, though not used in this job
    steps:
      - name: Try to show GitHub Variables # Renamed step for clarity based on original name
        run: |
          echo "deployment_type input is ${{ github.event.inputs.deployment_type }}" # Use input directly
          echo "commit_hash input is ${{ github.event.inputs.commit_hash }}" # Use input directly
          echo "deployment env input is ${{ github.event.inputs.deployment_environment }}" # Use input directly

  # --- Replaced find-commit, update-version, read-version ---
  versioning:
    # Using the reusable workflow
    uses: ./.github/workflows/reusable__generate-version.yml
    # Define necessary permissions for the reusable workflow's jobs (like push)
    permissions:
      packages: write
      id-token: write
      contents: write
      attestations: write
    with:
      # Pass the combined strategy or hash input
      version_strategy_or_hash: ${{ github.event.inputs.deployment_type == 'Release from Commit' && github.event.inputs.commit_hash || github.event.inputs.deployment_type }}
    secrets:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}


  build-docker-image:
    # Update dependency: now needs 'versioning' instead of 'read-version'
    needs: [versioning]
    uses: ./.github/workflows/reusable__build.yml
    with:
      COMMIT_HASH: ${{ github.head_ref || github.ref_name }}
      FULL_IMAGE_TAG: ${{needs.versioning.outputs.IMAGE_TAG}} # Use the output from the versioning job.



  e2e:
    needs: [build-docker-image, versioning]
    uses: ./.github/workflows/reusable__e2e-testing.yml
    with:
      DOCKER_IMAGE_TAG: ${{ needs.versioning.outputs.IMAGE_TAG }}



  deploy-release:
    needs:
      - e2e
      - versioning
    uses: ./.github/workflows/reusable__deploy-release.yml
    with:
      COMMIT_HASH: ${{needs.versioning.outputs.SHORT_COMMIT_HASH }}
      FULL_IMAGE_TAG: ${{ needs.versioning.outputs.IMAGE_TAG }}
      INFRA_OVERLAY_FOLDER: deployments/overlays
      OKR_INFRA_REPOSITORY_PATH: okr-infra # Kept as original
      PUZZLE_GITLAB_FQDN: ${{vars.PUZZLE_GITLAB_FQDN}}
      deployment_environment: ${{ inputs.deployment_environment }}
      SEMVER_VERSION: ${{ needs.versioning.outputs.SEMVER_VERSION }}
      create_release: true
    secrets:
      GITLAB_ACCESS_TOKEN: ${{ secrets.GITLAB_ACCESS_TOKEN }}
      DOCKER_REGISTRY: ${{ secrets.QUAY_REGISTRY }}
      DOCKER_USERNAME: ${{ secrets.QUAY_USERNAME }}
      DOCKER_REGISTRY_TOKEN: ${{ secrets.QUAY_TOKEN }}
#        DOCKER_REGISTRY: ${{ vars.DOCKER_REGISTRY }}
#        DOCKER_USERNAME: ${{ vars.DOCKER_USERNAME }}
#        DOCKER_REGISTRY_TOKEN: ${{ secrets.DOCKER_REGISTRY_TOKEN }}


