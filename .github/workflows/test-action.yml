name: 'Show Variables'

on:
  workflow_dispatch:
    inputs:
      deployment_type:
        type: choice
        description: Select type of deployment
        options:
          - Release from Commit
          - Major
          - Minor
          - Patch
        default: 'Release from Commit'
      commit_hash:
        description: 'The hash of thee commit that should be deployed, defaults to the latest commit on main'
        required: false
        type: string

      deployment:
        type: choice
        required: true
        description: On which environment should the deployment be done?
        options:
          - 'No deployment (only build)'
          - PROD
          - STAGING
          - DEMO
        default: 'No deployment (only build)'


jobs:
  debug:
    runs-on: ubuntu-24.04
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    steps:
      - name: Try to show GitHub Variables
        run: |
          echo "deployment_type is ${{ github.event.inputs.deployment_type }}" / ${{ inputs.deployment_type }}
          echo "commit_hash is ${{ github.event.inputs.commit_hash }}" / ${{ inputs.commit_hash }}

#  verify-input:
#    runs-on: ubuntu-24.04
#    steps:
#      - name: Verify input
#        run: |
#          echo "deployment_type is ${{ github.event.inputs.deployment_type }}" / ${{ inputs.deployment_type }}
#          echo "commit_hash is ${{ github.event.inputs.commit_hash }}" / ${{ inputs.commit_hash }}
#          echo "deployment is ${{ github.event.inputs.deployment }}" / ${{ inputs.deployment }}
  find-commit:
    runs-on: ubuntu-24.04
#    needs: verify-input
    outputs:
      COMMIT_HASH: "${{ env.COMMIT_HASH }}"
      SHORT_COMMIT_HASH: "${{ env.SHORT_COMMIT_HASH }}"
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Stores the commit hash as environment variable
        run: |
          commit_hash=$(./scripts/get-commit.sh ${{ env.BRANCH_NAME }} ${{ github.event.inputs.commit_hash }})
          echo "Commit is set to \"$commit_hash\""
          echo "COMMIT_HASH=$commit_hash" >> $GITHUB_ENV
          echo "SHORT_COMMIT_HASH=$(git rev-parse --short $commit_hash)" >> $GITHUB_ENV

      - name: Accessing the environment variable
        run: |
          echo "${{ env.SHORT_COMMIT_HASH }}"
      

  update-version:
    runs-on: ubuntu-24.04
    needs: find-commit
    if: github.event.inputs.deployment_type != 'Release from Commit'
#    outputs:
#      COMMIT_HASH: "${{ needs.find-commit.outputs.COMMIT_HASH }}".
#      SHORT_COMMIT_HASH: "${{ needs.find-commit.outputs.SHORT_COMMIT_HASH }}"
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    permissions:
      packages: write
      id-token: write
      contents: write
      attestations: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{env.BRANCH_NAME}}

      - name: Update version
        run: ./scripts/update-mvn-version.sh "${{ github.event.inputs.deployment_type }}"

      - name: Commit and Push Changes
        shell: bash
        env:
          COMMITPREFIX: '[VU]'
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "GitHub Actions"
          git add . || {
            echo "No files were changed, so we did not commit anything"
            exit 1
          }
          git commit -m "$COMMITPREFIX Automated version update" || {
            echo "No changes to commit, skipping push"
            exit 0
          }
          git push -f origin ${{ env.BRANCH_NAME }}

     

  read-version:
    runs-on: ubuntu-24.04
    needs: [update-version, find-commit]
    permissions:
      packages: write
      id-token: write
      contents: write
      attestations: write
    outputs:
      SEMVER_VERSION: ${{ steps.read_version_step.outputs.SEMVER_VERSION }}
      NEW_IMAGE_TAG: "${{vars.DOCKER_REPOSITORY_URL}}:${{ steps.read_version_step.outputs.SEMVER_VERSION }}-${{ needs.find-commit.outputs.SHORT_COMMIT_HASH }}"
    env:
      BRANCH_NAME: ${{ github.head_ref || github.ref_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          ref: ${{env.BRANCH_NAME}}

      - name: read version
        id: read_version_step
        run: |
          VERSION=$(mvn -q -Dexec.executable=echo -Dexec.args='${project.version}' --non-recursive exec:exec)
          echo "SEMVER_VERSION=$VERSION" >> $GITHUB_OUTPUT

  build-docker-image:
    needs: read-version
    runs-on: ubuntu-24.04
    steps:
      - uses: actions/checkout@v4
      - name: Accessing the environment variable
        run: |
          echo "${{ needs.read-version.outputs.NEW_IMAGE_TAG }}" 


      - name: Set up JDK ${{vars.JAVA_VERSION}}
        uses: actions/setup-java@v4
        with:
          java-version: ${{vars.JAVA_VERSION}}
          distribution: 'adopt'

      - name: Set up node ${{vars.NODE_VERSION}}
        uses: actions/setup-node@v4
        with:
          node-version: ${{vars.NODE_VERSION}}

      - name: Install Dependencies
        run: cd ./frontend && npm ci

      - name: Build frontend with Angular
        run: cd ./frontend && npm run build

      - name: Build backend with Maven
        run: mvn -B clean package --file pom.xml -P build-for-docker

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build the docker image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: docker/Dockerfile
          tags: ${{ needs.read-version.outputs.NEW_IMAGE_TAG}}
          load: true
          push: false
          outputs: type=docker,dest=/tmp/okr-docker-image.tar

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: okr-image
          path: /tmp/okr-docker-image.tar

#  e2e-docker:
#    runs-on: ubuntu-24.04
#    needs: [ build-docker-image,update-version]
#    strategy:
#      fail-fast: false
#      matrix:
#        file: ${{ fromJSON('[login.cy.ts]') }}
#
#    steps:
#      - uses: actions/checkout@v4
#
#      - name: Download artifact
#        uses: actions/download-artifact@v4
#        with:
#          name: okr-image
#          path: /tmp
#
#      - name: Load image
#        run: docker load --input /tmp/okr-docker-image.tar
#
#      - name: Run keyloak server
#        run: cd docker && docker compose up -d keycloak-pitc
#
#      - name: run Springboot okr application
#        run: |
#          docker run --network=host \
#          -e SPRING_PROFILES_ACTIVE=integration-test \
#          ${{ needs.update-version.outputs.okr-docker-image}} &
#
#      - name: set node version
#        uses: actions/setup-node@v4
#        with:
#          node-version: ${{vars.NODE_VERSION}}
#
#      - name: Cypress run e2e tests
#        uses: cypress-io/github-action@v6
#        with:
#          build: npm i -D cypress
#          working-directory: frontend
#          install: false
#          wait-on: 'http://pitc.okr.localhost:8080/config, http://localhost:8544'
#          wait-on-timeout: 120
#          browser: chrome
#          headed: false
#          config: baseUrl=http://pitc.okr.localhost:8080
#          spec: cypress/e2e/${{ matrix.file }}
#
#      - uses: actions/upload-artifact@v4
#        if: always()
#        with:
#          name: cypress-screenshots for ${{ matrix.file }}
#          path: frontend/cypress/screenshots


  upload-to-quay:
    runs-on: ubuntu-latest
    needs: [read-version, build-docker-image] #[e2e-docker, update-version]
    steps:
      - name: Checkout project
        uses: actions/checkout@v4

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: okr-image
          path: /tmp

      - name: Load image
        run: docker load --input /tmp/okr-docker-image.tar

      - name: show images
        run: docker image ls -a

      - name: Log in to Quay registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.QUAY_REGISTRY }}
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}

      - name: Push
        run: docker push ${{ needs.read-version.outputs.NEW_IMAGE_TAG}}

      #      - name: Install yq
      #        shell: bash
      #        env:
      #          VERSION: v4.25.2
      #          BINARY: yq_linux_amd64
      #        run: |
      #          wget -q https://github.com/mikefarah/yq/releases/download/${VERSION}/${BINARY}.tar.gz -O - |\
      #          tar xz && mv ${BINARY} /usr/local/bin/yq

  deploy-release:
    runs-on: ubuntu-latest
#    needs:
#      - upload-to-quay
    env:
      BRANCH_NAME: main
      COMMITER_EMAIL: actions@gitlab.com
      COMMITTER_NAME: GitLab Actions
      OVERLAY_ROOT_PATH: deployments/overlays
      INSTANCE_NAME: demo
      IMAGE_NAME: registry.puzzle.ch/puzzle/okr:3.1.5-SNAPSHOT-DEMO
    steps:
      - name: Checkout repository
        run: |
          git clone https://oauth2:${{ secrets.GITLAB_ACCESS_TOKEN }}@${{vars.PUZZLE_GITLAB_FQDN}}:${{vars.OKR_INFRA_REPOSITORY_PATH}}
          cd okr-infra
          git checkout ${{env.BRANCH_NAME}}

      - uses: imranismail/setup-kustomize@v1
        with:
          kustomize-version: 4.0.0

      - run: |
          cd okr-infra/${{env.OVERLAY_ROOT_PATH}}/${{env.INSTANCE_NAME}}
          kustomize edit set image ${{env.IMAGE_NAME}}

      - name: Commit and push
        run: |
          cd okr-infra/${{env.OVERLAY_ROOT_PATH}}/${{env.INSTANCE_NAME}}
          git config user.email "${{env.COMMITER_EMAIL}}"
          git config user.name "${{env.COMMITTER_NAME}}"
          git commit -am "Update image tag of ${{env.INSTANCE_NAME}} to ${{env.IMAGE_NAME}}"
          git pull --rebase
          git push




#        - name: Update YAML file
#          shell: bash
#          env:
#            COMMITPREFIX: '[CTS]'
#          run: |
#
#            curl -s --header "PRIVATE-TOKEN: ${{}}" "${{vars.TARGET_GITLAB_REPOSITORY}}/files/${{vars.GITLAB_FILEPATH}}?ref=${{vars.TARGET_GITLAB_REFERENCE}}" -H "Accept: application/json" -H "Content-Type: application/json" | jq -r '.content' | base64 --decode > response.yaml
#            yq -i "${{vars.YAML_PATH}} = \"${{needs.update-version.outputs.okr-docker-image}}\"" response.yaml
#            UPDATED_CONTENT=$(cat response.yaml)
#            curl --request PUT --header 'PRIVATE-TOKEN: ${{secrets.GITLAB_ACCESS_TOKEN}}' -F "branch=${{vars.TARGET_GITLAB_REFERENCE}}" -F "author_email=actions@gitlab.com" -F "author_name=GitLab Actions" -F "content=${UPDATED_CONTENT}" -F "commit_message=$COMMITPREFIX Automated changes to ${{vars.FILEPATH_COMMIT}}" "${{vars.TARGET_GITLAB_REPOSITORY}}/files/${{vars.GITLAB_FILEPATH}}"

#  create-release:
#    runs-on: ubuntu-24.04
#    needs: update-version
#    steps:
#      - name: Checkout
#        uses: actions/checkout@v4
#        with:
#          ref: ${{ needs.update-version.outputs.COMMIT_HASH }}
#
#      - name: Create git tag
#        run: |
#          git tag ${{ needs.update-version.outputs.SEMVER_VERSION }}
#      - name: Push git tag
#        run: git push origin ${{ needs.update-version.outputs.SEMVER_VERSION }}
#
#      - name: Create release
#        env:
#          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
#          tag: ${{ github.ref_name }}
#        run: |
#          gh release create "${{ needs.update-version.outputs.SEMVER_VERSION }}" \
#              --repo="$GITHUB_REPOSITORY" \
#              --title="Release ${GITHUB_REPOSITORY#*/} ${{ needs.update-version.outputs.SEMVER_VERSION }}" \
#              --generate-notes